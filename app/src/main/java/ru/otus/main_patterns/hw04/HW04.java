package ru.otus.main_patterns.hw04;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/*-
9. Команда
Домашнее задание: Макрокоманды

Цель: Научиться обрабатывать ситуации с точки зрения SOLID, когда требуется уточнить существующее поведение без модификации существующего кода.

Предположим, что у нас уже написаны команды MoveCommand и RotateCommand.
Теперь возникло новое требование: пользователи в игре могут устанавливать правило - во время движение расходуется топливо,
двигаться можно только при наличии топлива.

Реализовать новую возможность можно введя две новые команды.
CheckFuelCommand и BurnFuelCommand.
CheckFuelCommand проверяет, что топлива достаточно, если нет, то выбрасывает исключение CommandException.
BurnFuelCommand уменьшает количество топлива на скорость расхода топлива.

После этого мы можем три команды выстроить в цепочку.
CheckFuelCommand MoveCommand BurnFuelCommand

Чтобы это было прозрачно для пользователя реализуем Макрокоманду - специальную разновидность команды, которая в конструкторе принимает массив команда,
а в методе execute их все последовательно выполняет.

При повороте движущегося объекта меняется вектор мгновенной скорости.
Напишите команду, которая модифицирует вектор мгновенной скорости, в случае поворота.
Постройте цепочку команд для поворота.

Описание/Пошаговая инструкция выполнения домашнего задания:

 1.Реализовать класс CheckFuelComamnd и тесты к нему.
 2.Реализовать класс BurnFuelCommand и тесты к нему.
 3.Реализовать простейшую макрокоманду и тесты к ней. Здесь простейшая - это значит, что при выбросе исключения
   вся последовательность команд приостанавливает свое выполнение, а макрокоманда выбрасывает CommandException.
 4.Реализовать команду движения по прямой с расходом топлива, используя команды с предыдущих шагов.
 5.Реализовать команду для модификации вектора мгновенной скорости при повороте. Необходимо учесть, что не каждый разворачивающийся объект движется.
 6.Реализовать команду поворота, которая еще и меняет вектор мгновенной скорости, если есть.

Критерии оценки:
1.Домашнее задание сдано - 1 балл.
2.Реализована команда CheckFuelCommand - 1 балл
3.Написаны тесты к CheckFuelCommand - 1 балл
4.Реализована команда BurnFuelCommand - 1 балл
5.Написаны тесты к BurnFuelCommand - 1 балл
6.Реализована макрокоманда движения по прямой с расходом топлива и тесты к ней - 1 балл
7.Написаны тесты к MacroCommand - 1 балл
8.Реализована команда ChangeVelocityCommand - 1 балл
9.Написаны тесты к ChangeVelocityCommand - 1 балл
10.Реализована команда поворота, которая еще и меняет вектор мгновенной скорости - 1 балл

Итого: 10 баллов
Задание принято, если набрано не менее 7 баллов.

In class diagram:
Invoker - view. Invoker indirect call method action in class Receiver.
ConcreteCommand - controller
Receiver - implements some business logic.

Каждый шаг - это отдельная команда.
SOLID вариант команды это:
- команда не принимает аргументы
- команда не возвращает значение
- нужный набор параметров передается в конструкторе команд


Структура паттерна Команда:

    1.Отправитель(Invoker) хранит ссылку на объект команды и
    обращается к нему, когда нужно выполнить какое-то
    действие. Отправитель работает с командами только через
    их общий интерфейс. Он не знает, какую конкретно
    команду использует, так как получает готовый объект
    команды от клиента.

    2.Команда(Command) описывает общий для всех конкретных команд
    интерфейс. Обычно, здесь описан всего один метод для
    запуска команды.

    3.Конкретные команды(Concrete command) реализуют различные запросы,
    следуя общему интерфейсу команд. Обычно, команда не
    делает всю работу самостоятельно, а лишь передаёт вызов
    получателю — определённому объекту бизнес-логики.
    Параметры, с которыми команда обращается к получателю,
    следует хранить в виде полей. В большинстве случаев,
    объекты команд можно сделать неизменяемым, предавая в
    них все необходимые параметры только через конструктор.

    4.Получатель(Receiver) содержит бизнес-логику программы. В этой
    роли может выступать практически любой объект. Обычно,
    команды перенаправляют вызовы получателям. Но иногда,
    чтобы упростить программу, вы можете избавиться от
    получателей, слив их код в классы команд.

    5.Клиент(Client) создаёт объекты конкретных команд, передавая в
    них все необходимые параметры, а иногда и ссылки на
    объекты получателей. После этого, клиент конфигурирует
    отправителей созданными командами.

    Применимость:
    - Когда вы хотите параметризовать объекты выполняемым действием
    - Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
    - Когда вам нужна операция отмены
*/
public class HW04 {
    private static final Logger logger = LoggerFactory.getLogger(HW04.class);

    public static void main(String[] args) {
        logger.info("Java version: {}, Java vendor: {}\nДомашнее задание: Макрокоманды",
                System.getProperty("java.version"), System.getProperty("java.vendor"));

    }
}
