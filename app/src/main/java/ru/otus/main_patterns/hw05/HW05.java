package ru.otus.main_patterns.hw05;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/*-
    11. Расширяемая фабрика и IoC.
    Домашнее задание: Реализация IoC контейнера - частный случай расширяемой фабрики.

    Цель: Реализовать собственный IoC контейнер, устойчивый к изменению требований.
    В результате выполнения домашнего задания Вы получите IoC, который можно будет использовать в качестве фасада в своих проектах.

    Пошаговая инструкция выполнения домашнего задания:
    В игре "Космический бой" есть набор операций над игровыми объектами: движение по прямой, поворот, выстрел и т.д.
    При этом содержание этих команд может отличаться для разных игр, в зависимости от того, какие правила игры были выбраны пользователями.
    У каждой игры свой контекст(scope).
    Например, в одной игре пользователи могут ограничить запас каждого корабля некоторым количеством топлива,
    а в другой игре запретить поворачиваться кораблям по часовой стрелке и т.д.
    IoC может помочь в этом случае, скрыв детали в стратегии разрешения зависимости.

    Например:
     Command command = IoC<Command>.resolve("двигаться прямо", obj);

    ,возвращает команду, которая чаще всего является макрокомандой и осуществляет один шаг движения по прямой.

    Реализовать IoC контейнер, который:
    1. Разрешает зависимости с помощью метода, со следующей сигнатурой:
        T IoC.resolve(string key, params object[] args);
        Так реализуется параметрический полиморфизм в таких языках, как C++, C#, Java, Kotlin и др.
        Указание:
        Если язык программирования не поддерживает Generics, как, например, PHP, то запись Вам может быть незнакома.
        Тогда возвращайте просто ссылку на базовый класс.
    2. Регистрация зависимостей также происходит с помощью метода IoC.resolve(...):
        IoC.resolve("ioc.register", "aaa", (args) -> new A()).execute();
    3. Зависимости можно регистрировать в разных "scope-ах":
        IoC.resolve("ioc.scope.new", "scopeId").execute();
        IoC.resolve("ioc.scope.current", "scopeId").execute();

    Указание: Если Ваш фреймворк допускает работу с многопоточным кодом, то для работы со scope-ами используйте ThreadLocal контейнер.

    Критерии оценки:
        1. Интерфейс IoC устойчив к изменению требований.
            Оценка: 0 - 3 балла (0 - совсем не устойчив, 3 - преподаватель не смог построить ни одного контрпримера)
        2. IoC предоставляет ровно один метод для всех операций - 1 балл
        3. IoC предоставляет работу со scope-ами для предотвращения сильной связности - 2 балла.
        4. Реализованы модульные тесты - 2 балла
        5. Реализованы многопоточные тесты - 2 балла

    Пример IoC контейнера:
       https://github.com/etyumentcev/appserver/tree/main/appserver

    Scope = context

*/
public class HW05 {
  private static final Logger logger = LoggerFactory.getLogger(HW05.class);

  public static void main(String[] args) {
    logger.info(
        "Java version: {}, Java vendor: {}\nДомашнее задание: Реализация IoC контейнера",
        System.getProperty("java.version"),
        System.getProperty("java.vendor"));
  }
}
